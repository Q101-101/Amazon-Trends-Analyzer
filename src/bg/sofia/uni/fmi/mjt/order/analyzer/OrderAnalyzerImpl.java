package bg.sofia.uni.fmi.mjt.order.analyzer;

import bg.sofia.uni.fmi.mjt.order.domain.Category;
import bg.sofia.uni.fmi.mjt.order.domain.Order;
import bg.sofia.uni.fmi.mjt.order.domain.PaymentMethod;
import bg.sofia.uni.fmi.mjt.order.domain.Status;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class OrderAnalyzerImpl implements OrderAnalyzer {

    private static final double SUSPICIOUS_TOTAL_SALES = 100;
    private static final int SUSPICIOUS_NUM_OF_CANCELLED_ORDERS = 3;

    private final List<Order> orders;

    public OrderAnalyzerImpl(List<Order> orders) {
        this.orders = new ArrayList<Order>(orders);
    }

    @Override
    public List<Order> allOrders() {
        return List.copyOf(orders);
    }

    @Override
    public List<Order> ordersByCustomer(String customer) {
        if (customer == null || customer.isBlank()) {
            throw new IllegalArgumentException("Customer cannot be null or blank");
        }

        return List.copyOf( orders.stream().filter(order -> order.customerName().equals(customer)).toList() );
    }

    @Override
    public Map.Entry<LocalDate, Long> dateWithMostOrders() {
        return orders.stream().collect(Collectors.groupingBy(Order::date, Collectors.counting())).entrySet()
                .stream()
                .max(Map.Entry.<LocalDate, Long>comparingByValue(Comparator.reverseOrder())
                        .thenComparing(Map.Entry.comparingByKey())).orElse(null);
    }

    @Override
    public List<String> topNMostOrderedProducts(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("n must be >= 0");
        }
        if (n == 0) {
            return List.of();
        }

        return orders.stream()
                .collect(Collectors.groupingBy(Order::product, Collectors.counting()))
                .entrySet().stream()
                .sorted(Map.Entry.<String, Long>comparingByValue(Comparator.reverseOrder())
                                    .thenComparing(Map.Entry.comparingByKey()))
                .limit(n).map(Map.Entry::getKey).toList();
    }

    @Override
    public Map<Category, Double> revenueByCategory() {
        return orders.stream()
                .collect(Collectors.groupingBy(
                        Order::category,
                        Collectors.summingDouble(Order::totalSales)
                ));
    }

    @Override
    public Set<String> suspiciousCustomers() {
        return orders.stream()
                .filter(o -> o.status().equals(Status.CANCELLED))
                .filter(o -> o.totalSales() < SUSPICIOUS_TOTAL_SALES)
                .collect(Collectors.groupingBy(Order::customerName, Collectors.counting()))
                .entrySet().stream()
                .filter(e -> e.getValue() > SUSPICIOUS_NUM_OF_CANCELLED_ORDERS)
                .map(Map.Entry::getKey)
                .collect(Collectors.toSet());
    }

    @Override
    public Map<Category, PaymentMethod> mostUsedPaymentMethodForCategory() {
        if (orders.isEmpty()) {
            return Collections.emptyMap();
        }
        return orders.stream().collect(Collectors.groupingBy(Order::category,
                Collectors.groupingBy(Order::paymentMethod, Collectors.counting())))
                .entrySet().stream()
                .map(e -> {
                    Map.Entry<PaymentMethod, Long> maxEntry = e.getValue().entrySet().stream().findFirst().get();
                    for (var entry : e.getValue().entrySet()) {
                        if (entry.getValue() > maxEntry.getValue()) {
                            maxEntry = entry;
                        } else if (entry.getValue().equals(maxEntry.getValue())) {
                            if (entry.getKey().name().compareTo(maxEntry.getKey().name()) < 0) {
                                maxEntry = entry;
                            }
                        }
                    }
                    return  Map.entry(e.getKey(), maxEntry.getKey());
                })
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    @Override
    public String locationWithMostOrders() {
        return orders.stream()
                .collect(Collectors.groupingBy(Order::customerLocation, Collectors.counting()))
                .entrySet().stream()
                .max(Map.Entry.<String, Long>comparingByValue(Comparator.reverseOrder())
                        .thenComparing(Map.Entry.comparingByKey()))
                .map(Map.Entry::getKey).get();
    }

    @Override
    public Map<Category, Map<Status, Long>> groupByCategoryAndStatus() {
        return orders.stream()
                .collect(Collectors.groupingBy(Order::category,
                        Collectors.groupingBy(Order::status, Collectors.counting())));
    }
}
